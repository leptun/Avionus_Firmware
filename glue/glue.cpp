#include <FreeRTOS.h>
#include <task.h>
#include <main.h>
#include <AppMain.hpp>
#include <retarget_locks.h>
#include <quadspi.h>

extern "C" int __libc_init_array(void);
extern "C" void vPortSetupTimerInterrupt(void);
extern "C" int main();


HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority) {
	vPortSetupTimerInterrupt();
	return HAL_OK;
}
void HAL_IncTick(void) { Error_Handler(); }
uint32_t HAL_GetTick(void) { return (xPortIsInsideInterrupt() != pdFALSE) ? xTaskGetTickCountFromISR() : xTaskGetTickCount(); }
void HAL_Delay(uint32_t Delay) { if (xPortIsInsideInterrupt() == pdFALSE) vTaskDelay(Delay); } //todo implement spinlock or something for the case of ISR
void HAL_SuspendTick(void) { vTaskSuspendAll(); }
void HAL_ResumeTick(void) { xTaskResumeAll(); }

extern "C"
void vApplicationDaemonTaskStartupHook(void) {
	retarget_locks_init();
	__libc_init_array();

	main(); // generated by CubeMX
	if (CSP_QUADSPI_Init() != HAL_OK) {
		Error_Handler();
	}
	if (CSP_QSPI_EnableMemoryMappedMode() != HAL_OK) {
		Error_Handler();
	}
	AppMain::Setup();
}

extern "C"
void vApplicationMallocFailedHook(void) {
	__asm("BKPT #0\n");
}

extern "C"
void vApplicationStackOverflowHook(TaskHandle_t xTask, char *pcTaskName) {
	__asm("BKPT #0\n");
}

void glue_configPRE_SLEEP_PROCESSING(void) {
	LL_GPIO_ResetOutputPin(UI_LED_1_GPIO_Port, UI_LED_1_Pin);
}

void glue_configPOST_SLEEP_PROCESSING(void) {
	LL_GPIO_SetOutputPin(UI_LED_1_GPIO_Port, UI_LED_1_Pin);
}

extern "C"
int __io_putchar(int ch) {
	// Write character to ITM ch.0
	ITM_SendChar(ch);
	return(ch);
}
